This section will introduce the field of Quantum Computing, the theories and concepts and some algorithms, leading up to an adaptation of Shor's algorithm for discrete logarithms.
\subsection{Properties of Quantum Computers}
\subsubsection{Qubits}
To begin to describe quantum computing, we can start at the very basis of the concept. The basis of a classical computer is a bit, consisting of some transistor which can either have a voltage or not, i.e. the bit holds either a 1 or a 0. In a similar way, we can define the notion of a \emph{qubit}, the equivalent to a classical bit, and how it is physically implemented. Many particles and atoms posess a quality called "magnetic spin", which means that they can be deflected under a magnetic field. A particle's spin can either be up spin or down spin, meaning that the particle will either be deflected up or down when subject to a magnetic field, particles will never be deflected to the side or any other direction. Until we measure this spin property, the particle exists in a "superposition" of both up and down spin, and we have no way of predicting which type of spin the particle will have. Once the spin of the particle is measured, then this superposition collapses and the particle behaves in a non quantum way. A way of representing this spin is to assign a probability to each state as such: $$\ket{\psi} = \alpha_0\ket{0} + \alpha_1\ket{1}$$ Where $\ket{\psi}$ represents the superposition of the particle, $\alpha_0\ket{0}$ represents the probability $\alpha_0$ of the particle having up spin $\ket{0}$, and $\alpha_1\ket{1}$ represents the probability of the particle having down spin. The notation $\ket{0}$ is known as \emph{ket} notation, and is used frequently when describing quantum computing. This superposition then becomes our qubit, on which we can perform various operations to affect the output value, and the building block from which we can build a quantum system.
\subsubsection{Quantum States}
A classical system with n components, each of which can have two states (1 or 0) can be represented in full by n bits. A quantum system with n qubits would require $2^{n}$ complex number coefficients, or more precisely, the state of the quantum computer can be thought of as a point in a $2^{n}$-dimensional vector space, and for each of these $2^{n}$ states, we can represent them as a probability multiplied by a basis state, for example: $\alpha_i\ket{0010}$ means that the probability of the system being in state $\ket{0010}$ is equal to $\alpha_i$. The state of the whole system at any time can be represented by a \emph{Hilbert space} defined as:
$$ \ket{\psi} = \alpha_0\ket{\phi_0} + \alpha_1\ket{\phi_1} + ... + \alpha_{2n-1}\ket{\phi_{2n-1}} = \sum_{i=0}^{2^{n}-1} \alpha_{i} \ket{\phi_i} $$
where the amplitudes $a$ are complex numbers such that $\sum_{i}|\alpha_{i}|^{2} = 1$, and each $\ket{\phi_i}$ is a basis vector of the Hilbert space. The probability of the machine being at a basis state $\ket{\phi_i}$ at any time is $|\alpha_i|^2$, however reading the machines state at any time will invalidate the rest of the computation since this state will then be projected to the observed basis vector $\ket{\phi_i}$. For an example of this, suppose we have the quantum state: $\ket{\psi} = \frac{1}{\sqrt{3}}\ket{0} + \sqrt{\frac{2}{3}}\ket{1}$, then the probability of measuring the basis state $\ket{0}$ is equal to $\frac{1}{\sqrt{3}}^2 = \frac{1}{3}$, and the probability of measuring the basis state $\ket{1}$ is equal to $\sqrt{\frac{2}{3}}^2 = \frac{2}{3}$. We also have the \emph{conjugate} state, which can be represented in \emph{bra} notation: $\bra{\psi}$. If we have the quantum state $\ket{\psi} = \sum_i\alpha_i\ket{\phi_i}$, then the conjugate state is: $\bra{\psi} = \sum_i\alpha_i^*\bra{\phi_i} = \begin{pmatrix} \alpha_0^* & \alpha_1^* & ... & \alpha_{2n-1}^* \end{pmatrix}$ i.e. a row vector of the \emph{complex conjugates} of the elements of $\ket{\psi}$ with the complex conjugate of a complex number $a + b\textit{i}$ being $a -b\textit{i}$.
\subsubsection{Transformations on Quantum States}
Machine states can be described in vector format by taking all the coefficients as such: $$\ket{\psi} = \alpha_0\ket{\phi_0} + \alpha_1\ket{\phi_1} \equiv \begin{pmatrix} \alpha_0 \\ \alpha_1 \end{pmatrix}$$ We can then apply a transformation to this state such that the coefficients become $\alpha_0'$ and $\alpha_1'$: $$\ket{\psi'} = \alpha_0'\ket{\phi_0} + \alpha_1'\ket{\phi_1} \equiv \begin{pmatrix} \alpha_0' \\ \alpha_1' \end{pmatrix}$$ This transformation can be expressed as $$\ket{\psi'} = U\ket{\psi}$$ where $U$ is a $m\times m$ matrix with $m$ being the size of the state, which in our case is 2. Therefore, our transformation can be represented as: $$\begin{pmatrix} \alpha_0' \\ \alpha_1' \end{pmatrix} = \begin{pmatrix} u_{11} & u_{12} \\ u_{21} & u_{22} \end{pmatrix} \begin{pmatrix} \alpha_0 \\ \alpha_1 \end{pmatrix},$$ and we have that $\alpha_0' = u_{11}\alpha_0 + u_{12}\alpha_1$ and $\alpha_1' = u_{21}\alpha_0 + u_{22}\alpha_1$
\subsubsection{Entanglement}
If we have two independent qubits in the states $\ket{\psi_0} = \frac{1}{\sqrt{3}}\ket{0} + \sqrt{\frac{2}{3}}\ket{1}$ and $\ket{\psi_1} = \frac{1}{\sqrt{5}}\ket{0} + \frac{2}{\sqrt{5}}\ket{1}$, then we can create a composite system from these as such:
$$
\ket{\psi} = \frac{1}{\sqrt{3}}\frac{1}{\sqrt{5}}\ket{00} + \frac{1}{\sqrt{3}}\frac{2}{\sqrt{5}}\ket{01} + \sqrt{\frac{2}{3}}\frac{1}{\sqrt{5}}\ket{10} + \sqrt{\frac{2}{3}}\frac{2}{\sqrt{5}}\ket{11} $$
$$\ket{\psi} = \frac{1}{\sqrt{15}}\ket{00} + \frac{2}{\sqrt{15}}\ket{01} + \sqrt{\frac{2}{15}}\ket{10} + \frac{2\sqrt{2}}{\sqrt{15}}\ket{11}$$
These two qubits are then said to be entangled. Entangled qubits have a multitude of useful properties when designing quantum circuits, which will be discussed more in depth in a later section.
\subsection{Quantum Logic Gates}
Using the knowledge of quantum state transformations, we can create quantum logic gates in an analagous way to classical logic gates, for example, the quantum version of a NOT gate must simply flip the input qubits such that an input qubit: $\begin{pmatrix} \alpha_0 \\ \alpha_1 \end{pmatrix}$ is flipped to $\begin{pmatrix} \alpha_1 \\ \alpha_0 \end{pmatrix}$. We can see simply that this transformation can be represented as the matrix: $\begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}$. There are various other quantum logic gates which are very useful in a wide range of different quantum algorithms, however all quantum gates must be reversible, i.e. the matrix that describes them must be unitary. For a matrix to be unitary, it must be equal to the identity matrix when multiplied with its \emph{hermitian conjugate}. The hermitian conjugate of a matrix $U$, denoted as $U^\dag$, can be calculated as the original matrix transposed with each element being the complex conjugate of its original entry. For an example, we can look at a commonly used gate in quantum logic circuits, the Pauli-Y gate: $\begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix}$. The transpose of this matrix is: $\begin{pmatrix} 0 & i \\ -i & 0 \end{pmatrix}$, with the complex conjugate of this being equal to our original matrix: $\begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix}$. The reason why quantum logic gates must be unitary and therefore reversible, is that for a quantum state to be valid, it must be \emph{normalised}, which means that the inner product of itself and it's own conjugate state must be equal to 1. For example, for the state $\ket{\psi} = \begin{pmatrix} \alpha_0 \\ \alpha_1 \end{pmatrix}$, its inner product defined as $\braket{\psi'|\psi} = \alpha_0^*\alpha_0 + \alpha_1^*\alpha_1$ must be equal to 1. Now consider a transformation $\ket{\psi'} = U\ket{\psi}$, for the system to be normalised, we must have $\braket{\psi|\psi} = 1$ and $\braket{\psi'|\psi'} = 1$. This transformation can also be described in component notation as such: $$\ket{\psi'} = \begin{pmatrix} \alpha_0' \\ \alpha_1' \end{pmatrix} = \begin{pmatrix} u_{11} & u_{12} \\ u_{21} & u_{22} \end{pmatrix} \begin{pmatrix} \alpha_0 \\ \alpha_1 \end{pmatrix}$$ and $$\bra{\psi'} = \begin{pmatrix} \alpha_0'^* & \alpha_1'^* \end{pmatrix} = \begin{pmatrix} \alpha_0^* & \alpha_1^* \end{pmatrix} \begin{pmatrix} u_{11}^* & u_{21}^* \\ u_{12}^* & u_{22}^* \end{pmatrix},$$ therefore we have $\bra{\psi'} = \bra{\psi}U^\dag$, which leads to: $$\braket{\psi'|\psi'} = \bra{\psi}U^\dag U\ket{\psi} = \braket{\psi|\psi},$$ therefore, $U^\dag U$ must be equal to the identity matrix $I$.
\subsubsection{Hadamard Transform}
The Hadamard transform is a very commonly used quantum gate due to its useful properties: when the Hadamard transform is applied to a qubit, the qubit then has an equal chance of being measured as a $\ket{0}$ or a $\ket{1}$, regardless of the initial state of the qubit. The matrix for this transformation is: $$\frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$ We can prove that for a qubit in any initial state, when this transform is applied, will become an equal superposition of all base states. Suppose we have our initial qubit in state $\ket{0}$, i.e. its coefficients are: $\begin{pmatrix} 1 \\ 0 \end{pmatrix},$ then when we apply the transform we get: $$\frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \begin{pmatrix} 1 \\ 0 \end{pmatrix} = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 \\ 1 \end{pmatrix}$$ The same can be shown for initial state $\ket{1}$: $$\frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \begin{pmatrix} 0 \\ 1 \end{pmatrix} = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 \\ -1 \end{pmatrix}$$ The negative sign does not mean that this vector is different than our previous vector, as we can only measure the magnitude of the vector when taking a measurement. Therefore, when measuring both of these states it appears as if they are the same. The next section will describe how we can distinguish between these vectors. For an $n$ qubit system, we can apply $n$ Hadamard transform gates in parallel to gain a balanced superposition of all possible states.
\subsubsection{Phase Shift Gates}
There are a group of quantum logic gates which can be grouped under the set of "phase shift gates". These gates perform a rotation around a certain axis when applied to a qubit. To understand how these rotations work, it is helpful to think of qubit states as being a vector in a 3 dimensional unit sphere, where the typical notation: $$\ket{\psi} = \alpha_0\ket{0} + \alpha_1\ket{1}$$ can be represented as: 
\begin{align*} \ket{\psi} &= e^{i\gamma}(\cos{\frac{\theta}{2}}\ket{0} + (\cos{\phi} + i\sin{\phi})\sin{\frac{\theta}{2}}\ket{1}) \\
&= e^{i\gamma}(\cos{\frac{\theta}{2}}\ket{0} + e^{i\phi}\sin{\frac{\theta}{2}}\ket{1}),
\end{align*}
Where $\theta$ and $\psi$ are the relative phases, and $\gamma$ is the global phase of the vector. Figure \ref{fig:3Dvector} describes this. 
\begin{figure}[!htb]
\centering
\resizebox{7cm}{!}{\input{2_body/quantum/diagrams/3Dvector.tex}}
\caption{Vector Representation of Qubit Position}
\label{fig:3Dvector}
\end{figure}
If two vectors are only differing in their global phase, then they are indistinguishable when measuring, i.e. the two vectors below are the same when measured. $$\frac{-1}{\sqrt{2}}\ket{0} + \frac{1}{\sqrt{2}}\ket{1} \equiv \frac{1}{\sqrt{2}}\ket{0} - \frac{1}{\sqrt{2}}\ket{1}$$ When a Hadamard transform is applied, then their relative phases become different and hence the measurements become $\ket{0}$ and $\ket{1}$ respectively. $$\frac{1}{\sqrt{2}}\ket{0} + \frac{1}{\sqrt{2}}\ket{1}, \frac{1}{\sqrt{2}}\ket{0} - \frac{1}{\sqrt{2}}\ket{1}$$  We can now define phase shift gates as the gates which transform an input by rotating it along a certain axis. The base matrices for the rotations in X,Y and Z axis are defined below:
$$X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} Y = \begin{pmatrix} 0 & i \\ -i & 0 \end{pmatrix} Z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}$$
These are often referred to as Pauli-X Pauli-Y and Pauli-Z gates. More generally, we can have a rotation of a certain angle in the Z axis by using the matrix: $$\begin{pmatrix} 1 & 0 \\ 0 & e^{i\theta} \end{pmatrix},$$ which is commonly referred to the global phase shift gate, denoted as $R_\theta$.
\subsubsection{Quantum Circuits}
Quantum gates can be applied in a circuit in the same way that classical logic gates can. We use symbols to denote quantum gates as described in Figures \ref{fig:hadamardGate}, \ref{fig:phaseshiftGate}, \ref{fig:measurementGate} and \ref{fig:notGate}, where the lines denote inputs and outputs.
\begin{figure}[!htb]
\centering
\resizebox{2cm}{!}{\input{2_body/quantum/diagrams/hadamard.tex}}
\caption{Quantum circuit describing Hadamard gate}
\label{fig:hadamardGate}
\end{figure}\begin{figure}[!htb]
\centering
\resizebox{2cm}{!}{\input{2_body/quantum/diagrams/phaseshift.tex}}
\caption{Quantum circuit describing phase shift gate by arbitrary angle $\theta$}
\label{fig:phaseshiftGate}
\end{figure}\begin{figure}[!htb]
\centering
\resizebox{2cm}{!}{\input{2_body/quantum/diagrams/measurement.tex}}
\caption{Quantum circuit describing measurement gate}
\label{fig:measurementGate}
\end{figure}\begin{figure}[!htb]
\centering
\resizebox{2cm}{!}{\input{2_body/quantum/diagrams/not.tex}}
\caption{Quantum circuit describing NOT gate}
\label{fig:notGate}
\end{figure}
More commonly in quantum circuits, we use a controlled version of gates, which means that the gate takes two inputs, one of which controls the operation of the gate, for example the controlled not (CNOT) gate flips the target qubit if the control qubit is 1, otherwise it leaves it. The controlled not gate is described in Figure \ref{fig:cnotGate}. The concept of control gates can be extended to any unitary transformation.
\begin{figure}[!htb]
\centering
\resizebox{5cm}{!}{\input{2_body/quantum/diagrams/cnotcircuit.tex}}
\caption{Quantum circuits describing the effect of controlled not gate on different inputs}
\label{fig:cnotGate}
\end{figure}
The controlled not gate is an example of a multi-input gate, we can mix multi-input gates and single input gates in circuits, and this is required to create \emph{entangled} qubits which are useful in many quantum circuits. Consider the circuit in Figure \ref{fig:entangle}. We have a Hadamard gate acting on a single input, and a controlled not gate which takes the output from the Hadamard transform as its control input.
\begin{figure}[!htb]
\centering
\resizebox{3cm}{!}{\input{2_body/quantum/diagrams/entangle.tex}}
\caption{Quantum circuit describing how to create entangled states}
\label{fig:entangle}
\end{figure}
To see exactly what is happening in this circuit, we can split the circuit up, as described in Figure \ref{fig:splitEntangle} 
\begin{figure}[!htb]
\centering
\resizebox{5cm}{!}{\input{2_body/quantum/diagrams/splitEntangle.tex}}
\caption{Quantum circuit for entanglement split into components}
\label{fig:splitEntangle}
\end{figure}
When the circuit is split up in this way, we can describe what transformations are happening at each stage. The first Hadamard transform is only applied to one qubit. Since we have a two qubit input, the second qubit is left unchanged, and the output is only affected by the Hadamard transform on the first qubit. The transformation that a Hadamard gate performs on one qubit is as follows \begin{align*}
    \ket{0} \longrightarrow \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\\
    \ket{1} \longrightarrow \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})
\end{align*}
When we have a two qubit input, the transformation is as follows:
\begin{align*}
    \ket{00} \longrightarrow \frac{1}{\sqrt{2}}(\ket{00} + \ket{10})\\
    \ket{01} \longrightarrow \frac{1}{\sqrt{2}}(\ket{01} + \ket{11})\\
    \ket{10} \longrightarrow \frac{1}{\sqrt{2}}(\ket{00} - \ket{10})\\
    \ket{11} \longrightarrow \frac{1}{\sqrt{2}}(\ket{01} - \ket{11})
\end{align*}
The matrix for this transformation is:
$$ H_1 = 
\begin{pmatrix}
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & -1 & 0\\
0 & 1 & 0 & -1
\end{pmatrix}
$$
Since this is the output for the first part of the circuit, the input $\ket{I'}$ it is the input to the next part of the circuit. We can then obtain the matrix for the whole circuit, $M$, by multiplying this first matrix with the matrix for a controlled not gate as follows:
$$
M = N_c\times H_1 = \frac{1}{\sqrt{2}}
\begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1\\
0 & 0 & 1 & 0
\end{pmatrix}
\begin{pmatrix}
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & -1 & 0\\
0 & 1 & 0 & -1
\end{pmatrix} = \frac{1}{\sqrt{2}}
\begin{pmatrix}
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
0 & 1 & 0 & -1\\
1 & 0 & -1 & 0
\end{pmatrix}
$$
This matrix is then the transformation for the whole circuit, and transforms states in the following way:
\begin{align*}
    \ket{00} \longrightarrow \frac{1}{\sqrt{2}}(\ket{00} + \ket{11})\\
    \ket{01} \longrightarrow \frac{1}{\sqrt{2}}(\ket{01} + \ket{10})\\
    \ket{10} \longrightarrow \frac{1}{\sqrt{2}}(\ket{00} - \ket{11})\\
    \ket{11} \longrightarrow \frac{1}{\sqrt{2}}(\ket{01} - \ket{10})
\end{align*}
This set of output states is called a \emph{bell state}, and means that if we measure one of the output qubits, we know the value of the other without having to measure it, meaning that the qubits are entangled. Consider the first state: $$\frac{1}{\sqrt{2}}(\ket{00} + \ket{11})$$
If we split this into all possibilities of each qubit with probabilities for each qubit in each state as such:
$$(a\ket{0} + b\ket{1}) \times (c\ket{0} + d\ket{1}),$$
then we can represent all possible output states as
$$ac\ket{00}, ad\ket{01}, bc\ket{10}, bd\ket{11}$$
That means, for our state to be possible, we must have $ad,bc=0$ and $ac,bd=\frac{1}{\sqrt{2}}$. This is impossible in conventional practice, but since the quantum state does not obey the laws of classical mechanics, it is possible.
\subsection{Quantum Fourier Transform}
Another key example of a quantum logic circuit which is used in many quantum algorithms is the Quantum Fourier transform. This is a quantum version of the classical discrete Fourier transform, and can be recreated in a quantum circuit with a collection of gates. The QFT allows us to find the underlying periodic behaviour of a function, and so it is useful in many quantum algorithms.
\subsubsection{Discrete Fourier Transform} 
To understand how the Quantum Fourier transform allows us to find the period of a function, we can look at the classical discrete Fourier transform. The discrete Fourier transform essentially allows us to take a finite sequence of equally spaced samples of an input function with high noise and find the underlying periodic behaviour. This transformation is useful because it can break down a seemingly random signal composed of many different frequency waves into its component parts. The transformation is done using properties of sinusoidal waves and Euler's formula.
For a simple example of the discrete Fourier transform, we can apply it to a sample of a sine wave with frequency 1Hz and amplitude 1:
\begin{figure}[!htb]
\centering
\resizebox{7cm}{!}{\input{2_body/quantum/diagrams/sine.tex}}
\caption{Sine wave with frequency 1Hz and amplitude 1}
\label{fig:sine}
\end{figure}
We can take samples of this function's amplitude at equally spaced points. For this example we use a sampling frequency of 8 Hz:
\begin{figure}[!htb]
\centering
\resizebox{7cm}{!}{\input{2_body/quantum/diagrams/sineSample.tex}}
\caption{Sine wave sampled at 8Hz}
\label{fig:sineSample}
\end{figure}
The eight values for amplitude we get are displayed in Table \ref{table:amplitudes}
\begin{table}[!htb]
\centering
\begin{tabular}{ |c|c| } 
\hline
 & amplitude \\
\hline
$x_0$ & 0 \\ 
$x_1$ & 0.707 \\ 
$x_2$ & 1 \\ 
$x_3$ & 0.707 \\ 
$x_4$ & 0 \\ 
$x_5$ & -0.707 \\ 
$x_6$ & -1 \\ 
$x_7$ & -0.707 \\ 
\hline
\end{tabular}
\caption{Amplitudes of samples}
\label{table:amplitudes}
\end{table}
Using these values and the formula for the discrete Fourier transform, we can work out the frequency bins for each value by substituting in the values for k, n and $x_i$. When this is done, we get values for $X_k$ as shown in Table \ref{table:fourierCoefficient}
\begin{table}[!htb]
\centering
\begin{tabular}{ |c|c| } 
\hline
& Fourier Coefficient \\
\hline
$X_0$ & 0 \\ 
$X_1$ & 0 - 4\textit{i} \\ 
$X_2$ & 0 \\ 
$X_3$ & 0 \\ 
$X_4$ & 0 \\ 
$X_5$ & 0 \\ 
$X_6$ & 0 \\ 
$X_7$ & 0 + 4\textit{i} \\ 
\hline
\end{tabular}
\caption{Fourier Coefficients of samples}
\label{table:fourierCoefficient}
\end{table}
From this we can see that the only non-zero values are those for $X_1$ and $X_7$. We choose to take the magnitude of these rather than the full complex number for reasons that will be shown later. We can plot this as a frequency against magnitude graph as shown in Figure \ref{fig:nyquist}
\begin{figure}[!htb]
\centering
\resizebox{10cm}{!}{\input{2_body/quantum/diagrams/nyquist.tex}}
\caption{Frequency against magnitude plot for sample}
\label{fig:nyquist}
\end{figure}
The Nyquist limit is the highest frequency that can be coded at a given sampling rate to be able to fully reconstruct the original signal, and it is equal to $\frac{N}{2}$~\cite{tretter1976introduction}. Due to this, we remove all values above the Nyquist limit, and double all values below the Nyquist limit to account for the removed values. This leaves us with a result for only $X_1$, being a magnitude of 2*4 = 8. To get the amplitude of the original sample, we divide this amplitude by the number of samples. In this case we have $\frac{8}{8}$ which tells us that the amplitude of the original sample was 1. To find the frequency of the original sample, we have to look at the value of k. In this case it is 1, so our frequency was 1 Hz. We can also calculate the phase that this sinusoidal wave was shifted compared to a normal cosine wave. In order to do this we need to look at the complex number we obtained for $X_k$, which in this case was $0-8\textit{i}$. If we plot this on a complex plane we get an angle from the positive real axis to the plot, as shown in Figure \ref{fig:complex}
\begin{figure}[!htb]
\centering
\resizebox{6cm}{!}{\input{2_body/quantum/diagrams/complex.tex}}
\caption{Angle between positive real axis and sample}
\label{fig:complex}
\end{figure}
The angle $\theta$ is equal to $\frac{3\pi}{2}$, which is our phase shift from a normal cosine wave. This method can be used for any type of sample, and the results will be normalised against a cosine wave, so we can use it for statistical analysis of the sample.
\begin{figure}[!htb]
\centering
\resizebox{8cm}{!}{\input{2_body/quantum/diagrams/phase.tex}}
\caption{Phase shift of sample from cosine wave}
\label{fig:phase}
\end{figure}
\subsubsection{Applying the Quantum Fourier Transform}
The Quantum Fourier transform (QFT) works in a similar way as the discrete fourier transform, with the one major difference being that the QFT takes quantum states as inputs and outputs. It takes the quantum state $\ket{x} = \sum_{j=0}^{N-1}x_j\ket{i}$ and maps it to the quantum state  $\sum_{k=0}^{N-1}y_k\ket{k}$ according to the formula:
$$y_k = \frac{1}{\sqrt{N}}\sum_{j=0}^{N-1}x_j\cdot{e^{2\pi ijk/N}}$$
Consider the 2-qubit state $\ket{x} = a_0\ket{00} + a_1\ket{01} + a_2\ket{10} + a_3\ket{11}$, in this state, then we have $N = 2^2 = 4$. We can apply the QFT to each instance by subsituting in k as 0,1,2,3 respectively as follows:
$$y_0 = \frac{1}{2}\sum_{j=0}^{3}a_j=\frac{1}{2}(a_{00}+a_{01}+a_{10}+a_{11})$$
$$y_1 = \frac{1}{2}\sum_{j=0}^{3}a_j\cdot{\omega^j}=\frac{1}{2}(a_{00}+a_{01}\cdot{\omega}+a_{10}\cdot{\omega^2}+a_{11}\cdot{\omega^3})$$
$$y_2 = \frac{1}{2}\sum_{j=0}^{3}a_j\cdot{\omega^2j}=\frac{1}{2}(a_{00}+a_{01}\cdot{\omega^2}+a_{10}\cdot{\omega^4}+a_{11}\cdot{\omega^6})$$
$$y_3 = \frac{1}{2}\sum_{j=0}^{3}a_j\cdot{\omega^3j}=\frac{1}{2}(a_{00}+a_{01}\cdot{\omega^3}+a_{10}\cdot{\omega^6}+a_{11}\cdot{\omega^9})$$
These values can be represented in a matrix form as shown below:
$$F = \frac{1}{2}
\begin{pmatrix} 
1 & 1 & 1 & 1 \\
1 & \omega & \omega^2 & \omega^3 \\
1 & \omega^2 & \omega^4 & \omega^6 \\
1 & \omega^3 & \omega^6 & \omega^9 \\
\end{pmatrix} = \frac{1}{2} 
\begin{pmatrix}
1 & 1 & 1 & 1 \\
1 & \omega & \omega^2 & \omega^3 \\
1 & \omega^2 & 1 & \omega^2 \\
1 & \omega^3 & \omega^2 & \omega \\
\end{pmatrix} = \frac{1}{2} 
\begin{pmatrix}
1 & 1 & 1 & 1 \\
1 & i & -1 & -i \\
1 & -1 & 1 & -1 \\
1 & -i & -1 & i \\
\end{pmatrix}
$$
\subsubsection{Quantum Fourier Transform Circuit}
The Quantum Fourier transform can be represented as a quantum circuit, and we can prove that this performs the same transformation that we just obtained by observing the matrix for the transformation of the whole circuit. The QFT for a two qubit circuit is shown in Figure \ref{fig:qft2qubit}.
\begin{figure}[!htb]
\centering
\resizebox{5cm}{!}{\input{2_body/quantum/diagrams/QFT2Qubit.tex}}
\caption{Quantum Fourier Transform for a 2-qubit circuit}
\label{fig:qft2qubit}
\end{figure}
The gate at the end is called a \emph{swap} gate, and simply swaps the order of the qubits. This transformation is then as follows:
\begin{align*}
    \ket{00} \longrightarrow \ket{00}\\
    \ket{01} \longrightarrow \ket{10}\\
    \ket{10} \longrightarrow \ket{01}\\
    \ket{11} \longrightarrow \ket{11}
\end{align*}
and can be represented in matrix form as:
$$
\begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
$$
Other than the swap gate, we have a Hadamard transform acting on the first qubit only, then a controlled phase shift of order 2, then another Hadamard transform acting on the second qubit only. The generalised matrix for the controlled phase shift gate can be represented as:
$$
R_k = 
\begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1\\
0 & 0 & 0 &e^{2\pi i/2k}
\end{pmatrix}
$$
Therefore, the matrix for the $R_2$ gate is:
$$
R_2 = 
\begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1\\
0 & 0 & 0 & i
\end{pmatrix}
$$
We can then split the circuit into its seperate components as shown in Figure \ref{fig:qft2qubitsplit}, and represent it as a series of matrix multiplications which take the input from $\ket{I}$ to $\ket{A}$, $\ket{B}$, $\ket{C}$, and finally $\ket{O}$ respectively. 
\begin{figure}[!htb]
\centering
\resizebox{8cm}{!}{\input{2_body/quantum/diagrams/QFT2QubitSplit.tex}}
\caption{Quantum Fourier Transform for a 2-qubit circuit split into components}
\label{fig:qft2qubitsplit}
\end{figure}
These matrices can be denoted as $H_1$, $R_c(2)$, $H_2$, and $swap$ respectively. When we multiply these matrices out:
\begin{align*}
M &= swap \times H_2 \times R_c(2) \times H_1\\
&=
\begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1
\end{pmatrix} 
\frac{1}{\sqrt{2}}
\begin{pmatrix}
1 & 1 & 0 & 0\\
1 & -1 & 0 & 0\\
0 & 0 & 1 & 1\\
0 & 0 & 1 & -1
\end{pmatrix}
\begin{pmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & i
\end{pmatrix}
\frac{1}{\sqrt{2}}
\begin{pmatrix}
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & -1 & 0\\
0 & 1 & 0 & -1
\end{pmatrix},
\end{align*}
we can obtain the matrix for the whole circuit as:
$$
\frac{1}{2}
\begin{pmatrix}
1 & 1 & 1 & 1\\
1 & i & -1 & -i\\
1 & -1 & 1 & - 1\\
1 & -i & -1 & i
\end{pmatrix}
$$
We can see that indeed this is the same matrix as the one we obtained earlier, proving that this circuit performs the QFT for a two qubit circuit.
This circuit can be extended to a circuit with any number of input and output qubits as described in Figure \ref{fig:QFTnQubit}, and we can denote it in a larger circuit as a single gate to make things simpler using the notation in Figure \ref{fig:QFTgate}.
\begin{figure}[!htb]
\centering
\resizebox{\linewidth}{!}{\input{2_body/quantum/diagrams/QFTnQubit.tex}}
\caption{Quantum Fourier Transform for a n-qubit circuit}
\label{fig:QFTnQubit}
\end{figure}
\begin{figure}[!htb]
\centering
\resizebox{3cm}{!}{\input{2_body/quantum/diagrams/QFTgate.tex}}
\caption{Quantum Fourier Transform gate}
\label{fig:QFTgate}
\end{figure}
\subsection{Shor's Algorithms}
In his paper: \emph{Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Computer}~\cite{shor1999polynomial}, Peter W. Shor introduced two algorithms which are able to solve the prime factorisation problem and the discrete logarithm problem respectively in polynomial time. The algorithms both involve reducing the problem of finding either a prime factor or a discrete logarithm into a period finding problem, which can be completed on a quantum computer. The algorithms involve a number of steps which can be computed on a classical computer to avoid unnecessary complexity in the quantum circuit. The hardest part of the computation is calculating the period of the function which the problem can be reduced to.
\subsubsection{Shor's Algorithm for Prime Factorisation}
Shor's Algorithm for prime factorisation can be summarised in 5 steps. Suppose we have a number $N$, which has the factors $p$ and $q$: \\
1. If $N$ is even, prime or a prime power, there exists classical algorithms to calculate factorisation so exit.\\
2. Choose a random number $a$ < $N$ and calculate $\gcd(a,N)$, if this is not equal to 1, then we have found a factor of $N$ in $a$, so exit.\\
3. Find the period $r$ of the function$f(x) = a^x\mod N$. (This is the quantum aspect of the algorithm)\\
4. If $r$ is odd, or $a^{r/2}\mod N = -1\mod N$ then go back to step 1.\\
5. $\gcd(a^{r/2}\pm 1, N)$ are prime factors of $N$\\
Since we already have fast algorithms to calculate the classical parts of Shor's algorithm, this section will describe how we can use the properties of quantum computation to calculate the period of the function $f(x) = a^x\mod N$.
\subsubsection{Phase Estimation}
For some unitary operation on quantum state: $U\ket{\psi}$, if it is known that the state $\ket{\psi}$ is an \emph{eigenstate} of that operator, i.e. the quantum state does not change when it is operated on by $U$, then there exists a corresponding complex eigenvalue such that $U\ket{\psi} \equiv e^{2\pi i\phi}\ket{\psi}$, $0 \leq \phi < 1$~\cite{nielsen2002quantum}. We can design quantum circuits to estimate this value of $\phi$ to a certain number of decimal places. If we know both the value of $U$ and $\ket{\psi}$, we can estimate $\phi$ using the circuit described in Figure \ref{fig:phaseEstimationCircuit}.
\begin{figure}[!htb]
\centering
\hspace{-2.5cm}
\resizebox{10cm}{!}{\input{2_body/quantum/diagrams/phaseEstimationCircuit.tex}}
\caption{Phase Estimation Circuit~\cite{cleve1998quantum}}
\label{fig:phaseEstimationCircuit}
\end{figure}
This circuit involves two registers of qubits, $R_1$ and $R_2$. Register 1 contains $n$ qubits which are put into a superposition of all states using a series of parallel Hadamard transforms, i.e. the first register is initially in the state: $$\frac{1}{\sqrt{2^n}}\sum_{y=0}^{2^m-1}\ket{y}$$
Register 2 contains $m$ controlled U gates, each of which performs the square of the operation before it. The result of this is that the first register is put into a superposition of all values of our function. The state of the first register becomes: 
$$\frac{1}{\sqrt{2}}((\ket{0} + e^{2\pi i (2^{0} \phi} \ket{1})(\ket{0} + e^{2\pi i (2^{1} \phi} \ket{1})(\ket{0} + e^{2\pi i (2^{m-2} \phi} \ket{1})(\ket{0} + e^{2\pi i (2^{m-1} \phi} \ket{1}))$$
$$=\frac{1}{\sqrt{2^m}}\sum_{y=0}^{2^m-1}e^{2\pi i \phi y}\ket{y}$$
recall that the Quantum Fourier transform can be represented as 
$$\sum_{j=0}^{N-1}x_j\ket{i} \longrightarrow \sum_{k=0}^{N-1}y_k\ket{k},$$
where 
$$y_k = \frac{1}{\sqrt{N}}\sum_{j=0}^{N-1}x_j\cdot{e^{2\pi ijk/N}}$$
This means that, because $N = 2^m$ in our example, if we apply the \emph{inverse} of the QFT to this output, we get the state $\ket{2^m\phi}$ in our first register of $n$ qubits, and so we can measure the phase. The numbers of qubits needed in registers 1 and 2 are $n = 2\log_2 N$ and $m = \log_2 N$ respectively~\cite{kendon2004entanglement}.
\subsubsection{Quantum Circuit for Prime Factorisation}
The problem for finding the period of a function can be reformulated into a phase estimation problem. If we want to find the period $r$ of a function $$f(x) = a^x\mod N,$$ and we have a unitary operator which performs: $$U\ket{y} \longrightarrow \ket{xy\mod N},$$ which, as discussed in the previous section, can be replaced by its eigenvalue and eigenvector as such: $$e^{2\pi i\phi}\ket{\psi_s}$$ In fact, there are $r$ eigenvectors with corresponding eigenvalues, so $\ket{\psi_s}$ just denotes one of these eigenvectors. These eigenvalues can be represented as $e^{2\pi is/r}$~\cite{nielsen2002quantum}, which means that if we can measure the phase using our phase estimation circuit, we have a value for $\frac{s}{r}$. We do not need to know the specific eigenvector $\ket{\psi_s}$, as we can just put the system in a superposition of all possible vectors, and thus containing all $r$ eigenvectors. If we run a simulation representing this circuit, we see that the probability distribution forms peaks, these peaks correspond to each eigenvector, so it is more likely that when we take a measurement, we will measure the value of one of these peaks, which will give us a correct value for $r$. An example of the full circuit needed to factor 21 is described in Figure \ref{fig:shors21}. The next section will describe a practical example of how we can obtain the factors of a number using Shor's algorithm.
\begin{figure}[!htb]
\centering
\resizebox{10cm}{!}{\input{2_body/quantum/diagrams/shors21.tex}}
\caption{Quantum Circuit to Factorise 21}
\label{fig:shors21}
\end{figure}
\subsubsection{Example of Factorisation Using Shor's Algorithm}
Using the software {LIQU}i|>~\cite{1402.4467}, we were able to simulate a quantum circuit which would implement Shor's factorisation algorithm. When our input $N$ was 253, and a value of $a$ as 2, we obtained a measurement of $\ket{0001000001001010} = 4170$. Using the continued fraction algorithm described in Box 5.3 from \cite{nielsen2002quantum}, we can represent $\frac{4170}{2^{16}} = \frac{4170}{65536}$ as: $$0 + \frac{1}{15 + \frac{1}{1 + \frac{1}{2 + \frac{1}{1 + \frac{1}{1 + \frac{1}{10 + \frac{1}{1 + \frac{1}{7 + \frac{1}{1 + \frac{1}{2}}}}}}}}}}$$ with values for $d$ and $r$ as described in Table \ref{table:valuesdr}.
\begin{table}[!htb]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
$d$ & 1  & 1  & 3  & 4  & 7   & 74   & 81   & 641   & 722   & 2085  \\ \hline
$r$ & 15 & 16 & 47 & 63 & 110 & 1163 & 1273 & 10074 & 11347 & 32768 \\ \hline
\end{tabular}
\caption{Values for $d$ and $r$ obtained from continued fraction algorithm [Box 5.3]~\cite{nielsen2002quantum}}
\label{table:valuesdr}
\end{table}
Equation 5.3 in Shor's paper describes how we can obtain the value for $r$ from this set of values. There is at most one fraction $d/r$ with $r < N$ which satisfies the equation: $$\abs*{\frac{c}{q} - \frac{d}{r}} < \frac{1}{2q},$$ where $q$ is the power of 2 with $n^2 \leq q < 2n^2$, equal to $2^{16} = 65536$, and c is our observed value = 4170. Therefore the only values which satisfy this requirement in the table are $d = 7$ and $r = 110$. So we have obtained a value for the period of the function, $r$, as 110, now we can perform the last two steps in Shor's algorithm to calculate the factors of 253. Since $r$ is even and $a^{r/2}\mod N = 2^{55}\mod 253 = 208 \neq -1\mod 253$, our value for $r$ is correct. We can then obtain factors for 253 as $gcd(2^{55}\pm 1\mod 253, 253)$ which are 11 and 23 respectively. We can verify that $11\times 23$ is indeed equal to 253, so we have correctly obtained the prime factors of 253.
\subsubsection{Shor's Algorithm for Discrete Logarithms}
Shor's paper also describes a quantum routine for solving the discrete logarithm problem for a prime group $\mathbb{F}p$ \todo{Describe Shor's algorithm for discrete log briefly, then describe how it is adapated to any cyclic group using source 1 and 2}
\subsubsection{Quantum Circuit for Discrete Logarithms}
\subsection{Shor's Algorithm Adapted for the Elliptic and Hyperelliptic Curve Discrete Logarithm Problem}
